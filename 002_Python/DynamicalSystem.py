# -*- coding: utf-8 -*-
"""
Created on Fri May  8 16:58:03 2015

By now it's just a skeleton; Maybe it grows further in the coming days and weeks...

@author: johannesr
"""

import numpy as np
import scipy as sp

import Mesh
import Element
import Assembly
#import Boundary # the boundaries are in the Assembly module by now...
import Integrator


class DynamicalSystem():
    '''
    Base-class for the dynamic systems; It combines the modules to a black-box scheme for static and dynamic analysis.
    '''

    def __init__(self):
        '''Init-Function for the dynamical system;
        Main parameters are processed with the specific functions
        '''
        pass

    def load_mesh_from_gmsh(self, msh_file):
        '''Loads the mesh from a msh-file generated by gmsh. '''
        # internally store node_array and element_array to self.node_array and self.element_array
        pass

    def load_mesh_from_csv(self, node_list_csv, element_list_csv, trailing_index=False):
        '''Loads the mesh from two csv-files:
        node_list_csv:       contains the coordinates of the nodes (x, y, z);
        element_list_csv:    contains the nodes which belong to one element
        trailing_index:      flag which tells, if the csv-file has explicit element- and node-numbering
        '''
        # internally store node_array and element_array to self.node_array and self.element_array
        pass

    def apply_dirichlet_boundaries(self, dirichlet_boundary_list):
        '''
        Applies dirichlet-boundaries to the system.

        Parameters:
        -----------


        dirichlet_boundary_list:    list containing the dirichlet-boundary triples (DBT):
            [DBT_1, DBT_2, DBT_3, ]

            each dirchilet_boundary_triple is itself a list containing
            DBT = [master_dof=None, [list_of_slave_dofs], B_matrix=None]
            master_dof:    the dof onto which the slave dofs are projected. The master_dof will be overwritten at the end, i.e. if the master dof should participate at the end, it has to be a member in teh list of slave_dofs. If the master_dof is set to None, the slave_dofs will be fixed
            list_of_slave_dofs:   The list of the dofs which will be projected onto the master dof; the weights of the projection are stored in the B_matrix
            B_matrix:             The weighting-matrix which gives enables to apply complicated boundary conditions showing up in symmetry-conditions or rotational dofs. The default-value for B_matrix is None, which weighs all members of the slave_dof_list equally with 1.
        '''
        pass

    def apply_neumann_boundaries(self, neumann_boundary_list):
        '''Applies neumann-boundaries to the system.

        the neumann_boundary_list is a list containing the neumann_boundaries:

        [dofs, type, properties]
        types are
        type:             properties:
          - stepload      amplitude, time
          - dirac         amplitude, time
          - harmonic      amplitude, frequency

        This has to be elaborated further...
        the time dependent properties are ignored for static analysis
        '''
        pass

    def integrate_nonlinear_system(self, start_time, end_time, stepwidth, integrator_timestep):
        '''Integrate the given system considering the geometric nonlinearity.
        '''
        pass

    def integrate_linear_system(self, start_time, end_time, stepwidth, integrator_timestep):
        '''Integrate the given system ignoring geometric nonlinearity.
        '''
        pass

    def static_linear_analysis(self):
        '''Solve the linear system for the given boundary conditions
        '''
        pass

    def static_nonlinear_analysis(self):
        '''Solve the nonlinear system for the given boundary conditions;
        '''
        pass

    def export_paraview(self, filename):
        '''Export the system with the given information to paraview
        '''
        pass



# Idee, wie's ablaufen soll:
my_dynamical_system = DynamicalSystem()
my_dynamical_system.load_mesh_from_gmsh('gmsh/my_mesh.msh')
my_dirichlet_boundary_list = [[None, np.arange(40), None], [200, [200 + 2*i for i in range(40)], None]]
my_neumann_boundary_list = [[200, 'harmonic', (20, 2*np.pi*8)]]
my_dynamical_system.apply_dirichlet_boundaries(my_dirichlet_boundary_list)
my_dynamical_system.apply_neumann_boundaries(my_neumann_boundary_list)
my_dynamical_system.static_linear_analysis()
my_dynamical_system.export_paraview('ParaView/linear_static_testcase')
my_dynamical_system.integrate_nonlinear_system(0, 10, 0.01, 1E-4)
my_dynamical_system.export_paraview('Para_View/nonlinear_dynamic_testcase')

