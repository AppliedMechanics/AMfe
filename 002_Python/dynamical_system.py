# -*- coding: utf-8 -*-
"""
Created on Fri May  8 16:58:03 2015

By now it's just a skeleton; Maybe it grows further in the coming days and weeks...

@author: johannesr
"""

import numpy as np
import scipy as sp

import mesh
import element
import assembly
import boundary
import integrator


class DynamicalSystem():
    '''
    Base-class for the dynamic systems; It combines the modules to a black-box scheme for static and dynamic analysis.
    '''

    def __init__(self):
        '''Init-Function for the dynamical system;
        Main parameters are processed with the specific functions
        '''
        self.T_output = []
        self.u_output = []
        pass

    def load_mesh_from_gmsh(self, msh_file):
        '''Loads the mesh from a msh-file generated by gmsh. '''
        # internally store node_array and element_array to self.node_array and self.element_array
        pass

    def load_mesh_from_csv(self, node_list_csv, element_list_csv, node_dof=2, explicit_node_numbering=False):
        '''Loads the mesh from two csv-files:
        node_list_csv:       contains the coordinates of the nodes (x, y, z);
        element_list_csv:    contains the nodes which belong to one element
        trailing_index:      flag which tells, if the csv-file has explicit element- and node-numbering
        '''
        self.node_dof = node_dof=2
        self.mesh_class = mesh.Mesh()
        self.mesh_class.read_nodes_from_csv(node_list_csv, node_dof=node_dof, explicit_node_numbering=explicit_node_numbering)
        self.mesh_class.read_elements_from_csv(element_list_csv, explicit_node_numbering=explicit_node_numbering)
        self.node_list = self.mesh_class.nodes.copy()
        self.element_list = self.mesh_class.elements.copy()
        self.ndof_global = self.node_list.size


    def apply_dirichlet_boundaries(self, dirichlet_boundary_list):
        '''
        Applies dirichlet-boundaries to the system.

        Parameters:
        -----------

        dirichlet_boundary_list:    list containing the dirichlet-boundary triples (DBT)
            [DBT_1, DBT_2, DBT_3, ]

            each dirchilet_boundary_triple is itself a list containing
            DBT = [master_dof=None, [list_of_slave_dofs], B_matrix=None]
            master_dof:    the dof onto which the slave dofs are projected. The master_dof will be overwritten at the end, i.e. if the master dof should participate at the end, it has to be a member in teh list of slave_dofs. If the master_dof is set to None, the slave_dofs will be fixed
            list_of_slave_dofs:   The list of the dofs which will be projected onto the master dof; the weights of the projection are stored in the B_matrix
            B_matrix:             The weighting-matrix which gives enables to apply complicated boundary conditions showing up in symmetry-conditions or rotational dofs. The default-value for B_matrix is None, which weighs all members of the slave_dof_list equally with 1.
        '''
        self.dirichlet_bc_class = boundary.DirichletBoundary(self.ndof_global, dirichlet_boundary_list)
        self.b_constraints = self.dirichlet_bc_class.b_matrix()


    def apply_neumann_boundaries(self, neumann_boundary_list):
        '''Applies neumann-boundaries to the system.

        the neumann_boundary_list is a list containing the neumann_boundaries:

        [dofs_list, type, properties, B_matrix=None]
        types are
        type:             properties:
          - stepload      amplitude, time
          - dirac         amplitude, time
          - harmonic      amplitude, frequency
          - ramp          slope, time
          - const         amplitude

        This has to be elaborated further...
        the time dependent properties are ignored for static analysis
        '''
        self.neumann_bc_class = boundary.NeumannBoundary(self.ndof_global, neumann_boundary_list)
        self._f_ext_without_bc = self.neumann_bc_class.f_ext()

    def set_element(self, element_class):
        '''Gives the dynamical system routine an element class'''
        self.element_class = element_class
        pass

    def export_paraview(self, filename):
        '''Export the system with the given information to paraview
        '''
        pass

    def M_global(self):
        '''
        Return the global stiffness matrix with dirichlet boundary conditions imposed.
        Computes the Mass-Matrix every time again
        '''
        self.assembly_class = assembly.PrimitiveAssembly(self.node_list, self.element_list, self.element_class.m_int, node_dof=self.node_dof)
        _M = self.assembly_class.assemble_matrix()
        self._M_bc = self.b_constraints.T.dot(_M.dot(self.b_constraints))
        return self._M_bc

    def K_global(self, u=None):
        '''Return the global tangential stiffness matrix with dirichlet boundary conditions imposed'''
        self.assembly_class = assembly.PrimitiveAssembly(self.node_list, self.element_list, self.element_class.k_int, node_dof=self.node_dof)
        _K = self.assembly_class.assemble_matrix(self.b_constraints.dot(u))
        self._K_bc = self.b_constraints.T.dot(_K.dot(self.b_constraints))
        return self._K_bc

    def f_int_global(self, u):
        '''Return the global elastic restoring force of the system '''
        self.assembly_class = assembly.PrimitiveAssembly(self.node_list, self.element_list, node_dof=self.node_dof, vector_function=self.element_class.f_int)
        _f = self.assembly_class.assemble_vector(self.b_constraints.dot(u))
        self._f_bc = self.b_constraints.T.dot(_f)
        return self._f_bc

    def f_ext_global(self, u, du, t):
        '''return the global nonlinear external force of the right hand side of the equation, i.e. the excitation'''
        return self.b_constraints.T.dot(self._f_ext_without_bc(t))

    def write_timestep(self, t, u):
        '''
        write the timestep into the dynamical_system_class
        '''
        self.T_output.append(t)
        self.u_output.append(u.copy())







# Idee, wie's ablaufen soll:
my_dynamical_system = DynamicalSystem()
# my_dynamical_system.load_mesh_from_gmsh('gmsh/my_mesh.msh')
my_dynamical_system.load_mesh_from_csv('Vernetzungen/nodes.csv', 'Vernetzungen/elements.csv' )

my_element = element.ElementPlanar()
my_dynamical_system.set_element(my_element)

bottom_fixation = [None, range(20), None]
#bottom_fixation = [None, [1 + 2*x for x in range(10)], None]
#bottom_fixation2 = [None, [0, ], None]
conv = assembly.ConvertIndices(2)
master_node = conv.node2total(810, 1)
top_fixation = [master_node, [master_node + 2*x for x in range(10)], None]
dirichlet_boundary_list = [bottom_fixation, top_fixation]


# my_dirichlet_boundary_list = [[None, np.arange(40), None], [200, [200 + 2*i for i in range(40)], None]]
my_neumann_boundary_list = [[[master_node,], 'ramp', (8E1, 0), None]]
my_dynamical_system.apply_dirichlet_boundaries(dirichlet_boundary_list)
my_dynamical_system.apply_neumann_boundaries(my_neumann_boundary_list)


a = my_dynamical_system.f_ext_global(None, None, 0)
ndof_bc = len(a)
# Test
# my_dynamical_system.neumann_bc_class.function_list[0](3)

my_integrator = integrator.NewmarkIntegrator(alpha=0)
my_integrator.set_dynamical_system(my_dynamical_system)
my_integrator.verbose = True
my_integrator.integrate_nonlinear_system(np.zeros(ndof_bc), np.zeros(ndof_bc),  np.arange(0,0.4,0.05))

my_dynamical_system.export_paraview('ParaView/linear_static_testcase')
my_dynamical_system.export_paraview('Para_View/nonlinear_dynamic_testcase')

