# -*- coding: utf-8 -*-
"""
Created on Fri May  8 16:58:03 2015

By now it's just a skeleton; Maybe it grows further in the coming days and weeks...

@author: johannesr
"""

import numpy as np
import scipy as sp

if True:# __name__ == "__main__":
    from amfe.mesh import *
    from amfe.element import *
    from amfe.assembly import *
    from amfe.boundary import *


class MechanicalSystem():
    '''
    Base-class for the static and dynamic systems; It combines the modules to a black-box scheme for static and dynamic analysis.
    '''

    def __init__(self):
        '''Init-Function for the mechanical system;
        Main parameters are processed with the specific functions
        '''
        self.T_output = []
        self.u_output = []
        pass

    def load_mesh_from_gmsh(self, msh_file):
        '''Loads the mesh from a msh-file generated by gmsh. '''
        print('This feature is not implemented yet')
        # internally store node_array and element_array to self.node_array and self.element_array
        pass

    def load_mesh_from_csv(self, node_list_csv, element_list_csv, node_dof=2, explicit_node_numbering=False):
        '''Loads the mesh from two csv-files:
        node_list_csv:       contains the coordinates of the nodes (x, y, z);
        element_list_csv:    contains the nodes which belong to one element
        trailing_index:      flag which tells, if the csv-file has explicit element- and node-numbering
        '''
        self.node_dof = node_dof=2
        self.mesh_class = Mesh()
        self.mesh_class.read_nodes_from_csv(node_list_csv, node_dof=node_dof, explicit_node_numbering=explicit_node_numbering)
        self.mesh_class.read_elements_from_csv(element_list_csv, explicit_node_numbering=explicit_node_numbering)
        self.node_list = self.mesh_class.nodes.copy()
        self.element_list = self.mesh_class.elements.copy()
        self.ndof_global = self.node_list.size


    def apply_dirichlet_boundaries(self, dirichlet_boundary_list):
        '''
        Applies dirichlet-boundaries to the system.

        Parameters:
        -----------

        dirichlet_boundary_list:    list containing the dirichlet-boundary triples (DBT)
            [DBT_1, DBT_2, DBT_3, ]

            each dirchilet_boundary_triple is itself a list containing
            DBT = [master_dof=None, [list_of_slave_dofs], B_matrix=None]
            master_dof:    the dof onto which the slave dofs are projected. The master_dof will be overwritten at the end, i.e. if the master dof should participate at the end, it has to be a member in teh list of slave_dofs. If the master_dof is set to None, the slave_dofs will be fixed
            list_of_slave_dofs:   The list of the dofs which will be projected onto the master dof; the weights of the projection are stored in the B_matrix
            B_matrix:             The weighting-matrix which gives enables to apply complicated boundary conditions showing up in symmetry-conditions or rotational dofs. The default-value for B_matrix is None, which weighs all members of the slave_dof_list equally with 1.
        '''
        self.dirichlet_bc_class = DirichletBoundary(self.ndof_global, dirichlet_boundary_list)
        self.b_constraints = self.dirichlet_bc_class.b_matrix()


    def apply_neumann_boundaries(self, neumann_boundary_list):
        '''Applies neumann-boundaries to the system.

        the neumann_boundary_list is a list containing the neumann_boundaries:

        [dofs_list, type, properties, B_matrix=None]
        types are
        type:             properties:
          - stepload      amplitude, time
          - dirac         amplitude, time
          - harmonic      amplitude, frequency
          - ramp          slope, time
          - const         amplitude

        This has to be elaborated further...
        the time dependent properties are ignored for static analysis
        '''
        self.neumann_bc_class = NeumannBoundary(self.ndof_global, neumann_boundary_list)
        self._f_ext_without_bc = self.neumann_bc_class.f_ext()

    def set_element(self, element_class):
        '''Gives the mechanical system routine an element class'''
        self.element_class = element_class
        pass

    def export_paraview(self, filename):
        '''Export the system with the given information to paraview
        '''
        if len(self.T_output) is 0:
            self.T_output.append(0)
            self.u_output.append(np.zeros(self.ndof_global))
        self.mesh_class.set_displacement_with_time(self.u_output, self.T_output)
        self.mesh_class.save_mesh_for_paraview(filename)
        pass

    def M_global(self):
        '''
        Return the global stiffness matrix with dirichlet boundary conditions imposed.
        Computes the Mass-Matrix every time again
        '''
        self.assembly_class = PrimitiveAssembly(self.node_list, self.element_list, self.element_class.m_int, node_dof=self.node_dof)
        _M = self.assembly_class.assemble_matrix()
        self._M_bc = self.b_constraints.T.dot(_M.dot(self.b_constraints))
        return self._M_bc

    def K_global(self, u=None):
        '''Return the global tangential stiffness matrix with dirichlet boundary conditions imposed'''
        if u is None:
            u = np.zeros(self.b_constraints.shape[-1])
        self.assembly_class = PrimitiveAssembly(self.node_list, self.element_list, self.element_class.k_int, node_dof=self.node_dof)
        _K = self.assembly_class.assemble_matrix(self.b_constraints.dot(u))
        self._K_bc = self.b_constraints.T.dot(_K.dot(self.b_constraints))
        return self._K_bc

    def f_int_global(self, u):
        '''Return the global elastic restoring force of the system '''
        self.assembly_class = PrimitiveAssembly(self.node_list, self.element_list, node_dof=self.node_dof, vector_function=self.element_class.f_int)
        _f = self.assembly_class.assemble_vector(self.b_constraints.dot(u))
        self._f_bc = self.b_constraints.T.dot(_f)
        return self._f_bc

    def f_ext_global(self, u, du, t):
        '''return the global nonlinear external force of the right hand side of the equation, i.e. the excitation'''
        return self.b_constraints.T.dot(self._f_ext_without_bc(t))

    def write_timestep(self, t, u):
        '''
        write the timestep to the mechanical_system class
        '''
        self.T_output.append(t)
        self.u_output.append(self.b_constraints.dot(u))

