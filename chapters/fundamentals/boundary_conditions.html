<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Boundary Conditions &#8212; AMfe 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Mechanical System" href="mechanical_system.html" />
    <link rel="prev" title="Assembly" href="assembly.html" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="This is the documentation of AMfe">
    <meta name="author" content="Johannes Rutzmoser and Christian Meyer">
    <link rel="icon" href="../../favicon.ico">

    
    <!-- Bootstrap core CSS -->
    <link href="../../_static/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap theme -->
    <link href="../../_static/css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

    <!-- Custom styles for this template -->
    <link href="../../_static/css/theme.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- <script src="../../assets/js/ie-emulation-modes-warning.js"></script> -->

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
      
      
    <![endif]-->

  </head>
  <body role="document">

    <div class="document">


       <!-- Static navbar -->
    <nav class="navbar navbar-toggleable-md navbar-inverse bg-primary" id="main-nav">
        <div class="container-fluid">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="#"><img src="../../_static/img/logo.png" alt="" width="30" height="30" class="d-inline-block align-top">
                  AMfe Documentation
              </a>
            </div>
            <div id="navbar" class="collapse navbar-collapse">
              <ul class="nav navbar-nav">
                <li class="nav-item active"><a href="../../index.html">Home</a></li>
                <li class="nav-item"><a class="nav-link" href="../getting_started/index.html">Tutorials</a></li>
                <li class="nav-item"><a class="nav-link" href="index.html">Fundamentals</a></li>
                <li class="nav-item"><a class="nav-link" href="../examples/index.html">Examples</a></li>
                <li class="nav-item"><a class="nav-link" href="../../contents.html">Table of Contents</a></li>
                <li class="nav-item"><a class="nav-link" href="../../genindex.html">Index</a></li>
                <li class="nav-item"><a class="nav-link" href="../../py-modindex.html">Modules</a></li>
              </ul>
            </div>
        </div>
    </nav>
    
    
    <div class="container">
        <div class="row">
            
    <ul class="pager">
      <li class="previous">
        <a href="assembly.html" title="Assembly">&laquo; Previous</a>
      </li>
      <li class="previous">
        <a href="index.html" title="Fundamentals" accesskey="U">up</a>
      </li>
    <li class="next">
     <a href="mechanical_system.html" title="Mechanical System">next &raquo;</a>
    </li>
      </ul>
        </div>
        <div class="row">
            
  <div class="section" id="boundary-conditions">
<h1>Boundary Conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">¶</a></h1>
<p>In general there are two types of boundary conditions one can impose on structures:</p>
<ol class="arabic simple">
<li>Dirichlet Boundary Conditions</li>
<li>Neumann Boundary Conditions</li>
</ol>
<p>Dirichlet Boundary Conditions impose displacements on certain degrees of freedom.
Neumann Boundary Conditions impose forces on certain degrees of freedom.</p>
<p>There is a third kind of condition which is similar to Dirichlet Boundary Conditions: Constraints.
In AMfe constraints are treated similarly to Dirichlet Boundary Conditions.
They are applied by elimination technique.</p>
<p>This guide shows how boundary conditions and constraints can be imposed in AMfe.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This guide goes a bit in detail how AMfe treats boundary conditions. If you only want to know how to impose the
boundary conditions in a convenient way, then it is recommended to read the guide about mechanical_system module
instead.</p>
</div>
<div class="section" id="how-dirichlet-boundary-conditions-and-constraints-are-organized">
<h2>How Dirichlet Boundary Conditions and Constraints are organized<a class="headerlink" href="#how-dirichlet-boundary-conditions-and-constraints-are-organized" title="Permalink to this headline">¶</a></h2>
<p>The main class to handle Dirichlet Boundary Conditions is
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary" title="amfe.boundary.DirichletBoundary"><code class="xref py py-class docutils literal"><span class="pre">DirichletBoundary</span></code></a>.
However, there are also two properties in the
<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh" title="amfe.mesh.Mesh"><code class="xref py py-class docutils literal"><span class="pre">Mesh</span></code></a>-class that help to define Dirichlet Boundary Conditions.
Table <a class="reference internal" href="#tab-diric-properties"><span class="std std-numref">Table 5</span></a> gives an overview over the properties that can be set to define
Dirichlet Boundary conditions and linear, holonomic, skleronomic, homogene constraints.</p>
<table border="1" class="docutils" id="id1">
<span id="tab-diric-properties"></span><caption><span class="caption-number">Table 5 </span><span class="caption-text">Important properties that control the dirichlet boundary conditions and constraints</span><a class="headerlink" href="#id1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Property</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.nodes_dirichlet" title="amfe.mesh.Mesh.nodes_dirichlet"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.nodes_dirichlet</span></code></a></td>
<td>Contains a unique set of all node-ids where Dirichlet boundary conditions are imposed to</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.dofs_dirichlet" title="amfe.mesh.Mesh.dofs_dirichlet"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.dofs_dirichlet</span></code></a></td>
<td>Contains a unique set of all global dof-ids where Dirichlet boundary conditions are imposed to</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.slave_dofs" title="amfe.boundary.DirichletBoundary.slave_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.slave_dofs</span></code></a></td>
<td>Contains the constrained dofs</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.B" title="amfe.boundary.DirichletBoundary.B"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.B</span></code></a></td>
<td>A mapping matrix between the free dofs of the unconstrained and the constrained system</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.no_of_constrained_dofs" title="amfe.boundary.DirichletBoundary.no_of_constrained_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.no_of_constrained_dofs</span></code></a></td>
<td>Contains the number of free dofs of the constrained system</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.no_of_unconstrained_dofs" title="amfe.boundary.DirichletBoundary.no_of_unconstrained_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.no_of_unconstrained_dofs</span></code></a></td>
<td>Contains the number of dofs of the unconstrained system (all dofs when no constraints were imposed)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.row" title="amfe.boundary.DirichletBoundary.row"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.row</span></code></a></td>
<td>row indices of (row,col,val)-triplet of constraint matrix C (only needed for systems with multipoint constraints)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.col" title="amfe.boundary.DirichletBoundary.col"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.col</span></code></a></td>
<td>column indices of (row,col,val)-triplet of constraint matrix C (only needed for systems with multipoint constraints)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.val" title="amfe.boundary.DirichletBoundary.val"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.val</span></code></a></td>
<td>values of (row,col,val)-triplet of the constraint matrix C (only needed for systems with multipoint constraints</td>
</tr>
</tbody>
</table>
<p>Dirichlet boundary conditions are set if the first six properties are set properly.
If constraints are also imposed, then row, col and val attributes are also needed.</p>
<div class="section" id="the-b-matrix">
<h3>The B-Matrix<a class="headerlink" href="#the-b-matrix" title="Permalink to this headline">¶</a></h3>
<p>The heart of Dirichlet Boundary Conditions and Constraints is the B-matrix which is stored in the
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.B" title="amfe.boundary.DirichletBoundary.B"><code class="xref py py-attr docutils literal"><span class="pre">B</span></code></a>-property.
This matrix maps all dofs of the full mesh i.e. all dofs of the unconstrained system to the remaining dofs of the
constrained system.
The remaining dofs i.e. the dofs of the constrained system are called master-dofs. The other dofs i.e. the eliminated
dofs are called slave-dofs.
Therefore the relation</p>
<div class="math">
\[\begin{split}u_{unconstrained system} = B \ u_{constrained system} \quad \text{oder} \quad
\begin{bmatrix}
u_{master} \\ u_{slave} \end{bmatrix} = B \  u_{master}\end{split}\]</div>
<p>The constraints can then be imposed very simply to e.g. the stiffness matrix by</p>
<div class="math">
\[K_{constrained} = B^T \, K \, B\]</div>
<p>This can be done by calling the method
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.constrain_matrix" title="amfe.boundary.DirichletBoundary.constrain_matrix"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.constrain_matrix(Matrix)</span></code></a>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">constrain_matrix</span><span class="p">(</span><span class="n">K_unconstrained</span><span class="p">)</span>
</pre></div>
</div>
<p>If one wants to constrain a vector such as the nonlinear restoring force one suich that</p>
<div class="math">
\[f_{constrained} = B^T \, f\]</div>
<p>one calls
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.constrain_vec" title="amfe.boundary.DirichletBoundary.constrain_vec"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.constrain_vec(vector)</span></code></a>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">constrain_vec</span><span class="p">(</span><span class="n">f_unconstrained</span><span class="p">)</span>
</pre></div>
</div>
<p>The B matrix is generated such that</p>
<div class="math">
\[\begin{split}\begin{bmatrix} \vec u_{master} \\
\vec u_{slave}
\end{bmatrix}
=
\begin{bmatrix} 1 &amp; 0 \\
C &amp; 1
\end{bmatrix}
\begin{bmatrix}
\vec u_{master} \\
\vec u_{slave}
\end{bmatrix}\end{split}\]</div>
<p>where C is the constraint matrix (see sections below) and afterwards the columns stored in the
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.slave_dofs" title="amfe.boundary.DirichletBoundary.slave_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.slave_dofs</span></code></a>-property
are dropped. One gets the relation</p>
<div class="math">
\[\begin{split}\begin{bmatrix} \vec u_{master} \\ \vec u_{slave} \end{bmatrix}
=
\underbrace{\begin{bmatrix} 1 \\ C \end{bmatrix}}_B
\vec u_{master}\end{split}\]</div>
<p>The matrix B is stored in the <a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.B" title="amfe.boundary.DirichletBoundary.B"><code class="xref py py-attr docutils literal"><span class="pre">B</span></code></a>-property of the DirichletBoundary-class.
It can be updated by using the <a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.update" title="amfe.boundary.DirichletBoundary.update"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.update()</span></code></a>-method or can be returned
by calling <a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.b_matrix" title="amfe.boundary.DirichletBoundary.b_matrix"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.b_matrix()</span></code></a>-method.</p>
<p>If one wants to get the full displacement vector of all dofs from the displacement of the master-dofs one can call
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.unconstrain_vec" title="amfe.boundary.DirichletBoundary.unconstrain_vec"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.unconstrain_vec(u)</span></code></a> which returns
<span class="math">\(B \cdot u\)</span>.</p>
</div>
</div>
<div class="section" id="dirichlet-boundary-conditions">
<h2>Dirichlet Boundary Conditions<a class="headerlink" href="#dirichlet-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>Applying Dirichlet Boundary Condition is usually done in two steps:</p>
<ol class="arabic simple">
<li>Set the properties of the mesh class (<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.nodes_dirichlet" title="amfe.mesh.Mesh.nodes_dirichlet"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.nodes_dirichlet</span></code></a>, <a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.dofs_dirichlet" title="amfe.mesh.Mesh.dofs_dirichlet"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.dofs_dirichlet</span></code></a>)</li>
<li><dl class="first docutils">
<dt>Create a DirichletBoundary object and assign its properties (<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.slave_dofs" title="amfe.boundary.DirichletBoundary.slave_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.slave_dofs</span></code></a>,</dt>
<dd><a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.B" title="amfe.boundary.DirichletBoundary.B"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.B</span></code></a>, <a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.no_of_constrained_dofs" title="amfe.boundary.DirichletBoundary.no_of_constrained_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.no_of_constrained_dofs</span></code></a>,
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.no_of_unconstrained_dofs" title="amfe.boundary.DirichletBoundary.no_of_unconstrained_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.no_of_unconstrained_dofs</span></code></a>)</dd>
</dl>
</li>
</ol>
<div class="section" id="example-the-hard-way">
<h3>Example - The hard way<a class="headerlink" href="#example-the-hard-way" title="Permalink to this headline">¶</a></h3>
<p>In this example we show the deepest way to assign Dirichlet boundary conditions in AMfe.
It is shown that setting the first six properties shown in <a class="reference internal" href="#tab-diric-properties"><span class="std std-numref">Table 5</span></a> is sufficient to apply Dirichlet boundary
conditions. Consider the following example:</p>
<div class="figure" id="id2">
<span id="simple-geo-dbc"></span><img alt="../../_images/simple_geo.svg" src="../../_images/simple_geo.svg" /><p class="caption"><span class="caption-number">Fig. 6 </span><span class="caption-text">Simple mesh-geometry</span></p>
</div>
<p><a class="reference internal" href="#simple-geo-dbc"><span class="std std-numref">Fig. 6</span></a> shows a simple mesh-geometry with two elements and 6 nodes.</p>
<p>We want to fix node 0 in x- and y-direction and node 3 in x-direction. Due to the node numbering convention in AMfe,
these degrees of freedom have the IDs 0,1 and 6.
If not already done, we need to define the mesh and initialize a DirichletBoundary instance:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span> <span class="o">=</span> <span class="n">amfe</span><span class="o">.</span><span class="n">Mesh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># Several operations to define the mesh above...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span> <span class="o">=</span> <span class="n">amfe</span><span class="o">.</span><span class="n">DirichletBoundary</span><span class="p">()</span>
</pre></div>
</div>
<p>Then the first step is setting the properties of the Mesh-class:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span><span class="o">.</span><span class="n">nodes_dirichlet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span><span class="o">.</span><span class="n">dofs_dirichlet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
</pre></div>
</div>
<p>The second step is setting the properties of the DirichletBoundary class:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">slave_dofs</span> <span class="o">=</span> <span class="n">msh</span><span class="o">.</span><span class="n">dofs_dirichlet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
</pre></div>
</div>
<p>The method <a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.update" title="amfe.boundary.DirichletBoundary.update"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.update()</span></code></a> updates the properties
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.B" title="amfe.boundary.DirichletBoundary.B"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.B</span></code></a>
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.no_of_constrained_dofs" title="amfe.boundary.DirichletBoundary.no_of_constrained_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.no_of_constrained_dofs</span></code></a>
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.no_of_unconstrained_dofs" title="amfe.boundary.DirichletBoundary.no_of_unconstrained_dofs"><code class="xref py py-attr docutils literal"><span class="pre">DirichletBoundary.no_of_unconstrained_dofs</span></code></a>.</p>
<p>Although this is a quite hard way to impose Dirichlet Boundary conditions, it could still be helpful because the more
convenient ways require that the Dirichlet Boundary conditions have to be imposed on elements that belong to the same
physical group that is defined in the <a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.el_df" title="amfe.mesh.Mesh.el_df"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.el_df</span></code></a>-property.</p>
</div>
<div class="section" id="example-the-more-convenient-way">
<h3>Example - The more convenient way<a class="headerlink" href="#example-the-more-convenient-way" title="Permalink to this headline">¶</a></h3>
<p>The same steps can be done in a more convenient way if a mesh-property (a physical group is avilable).
The first step i.e. setting the mesh properties <a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.nodes_dirichlet" title="amfe.mesh.Mesh.nodes_dirichlet"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.nodes_dirichlet</span></code></a> and
<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.dofs_dirichlet" title="amfe.mesh.Mesh.dofs_dirichlet"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.dofs_dirichlet</span></code></a> can be done by calling the method
<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.set_dirichlet_bc" title="amfe.mesh.Mesh.set_dirichlet_bc"><code class="xref py py-meth docutils literal"><span class="pre">set_dirichlet_bc</span></code></a>:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span><span class="o">.</span><span class="n">set_dirichlet_bc</span><span class="p">(</span><span class="mi">101</span><span class="p">,</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The first argument of the method is the physical group of the mesh where the boundary condition shall be assigned to.
The second argument is a string that contains the coordinates (directions) where the boundary condition shall be
assigned to. After calling this method both properties are extended by those degrees of freedom that belong to the
passed physical group and the coordinates.</p>
<p>The second step i.e. setting propeties of the DirichletBoundary class can be done by calling:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">constrain_dofs</span><span class="p">(</span><span class="n">msh</span><span class="o">.</span><span class="n">dofs_dirichlet</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The most convenient way to apply dirichlet boundary conditions is to use the mechanical_sytem class and its
method <a class="reference internal" href="../package_doc/amfe.mechanical_system.html#amfe.mechanical_system.MechanicalSystem.apply_dirichlet_boundaries" title="amfe.mechanical_system.MechanicalSystem.apply_dirichlet_boundaries"><code class="xref py py-meth docutils literal"><span class="pre">apply_dirichlet_boundaries</span></code></a>.</p>
</div>
</div>
<div class="section" id="option-external">
<h3>Option &#8216;External&#8217;<a class="headerlink" href="#option-external" title="Permalink to this headline">¶</a></h3>
<p>The method <a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.set_dirichlet_bc" title="amfe.mesh.Mesh.set_dirichlet_bc"><code class="xref py py-meth docutils literal"><span class="pre">set_dirichlet_bc</span></code></a>
has the option output=&#8217;external&#8217;.
If this option is set, the method returns the nodes and dofs that would be fixed if the Dirichlet boundary condition
<strong>would</strong> be applied. In fact the boundary condition is not applied.
The returned values can be used for further more complicated steps. This can be helpful e.g. for applying
constraints (see section below).</p>
<p>In the following example we fix the dofs that belong to physical group 101 in two steps:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span> <span class="o">=</span> <span class="n">amfe</span><span class="o">.</span><span class="n">Mesh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="c1"># Several operations to define the mesh topology...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span><span class="p">,</span> <span class="n">dofs</span> <span class="o">=</span> <span class="n">msh</span><span class="o">.</span><span class="n">set_dirichlet_bc</span><span class="p">(</span><span class="mi">101</span><span class="p">,</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;external&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">constrain_dofs</span><span class="p">(</span><span class="n">dofs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="applying-constraints">
<h2>Applying constraints<a class="headerlink" href="#applying-constraints" title="Permalink to this headline">¶</a></h2>
<p>The main or deepest function to apply constraints to the system is
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.add_constraints" title="amfe.boundary.DirichletBoundary.add_constraints"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.add_constraints(slave_dofs,</span> <span class="pre">row,</span> <span class="pre">col,</span> <span class="pre">val)</span></code></a>.
This function can apply holonomic, skleronomic, homogene constraints of the following kind:</p>
<div class="math">
\[\vec u_{slave} = C \ \vec u_{master}\]</div>
<p>For example run:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">add_constraints</span><span class="p">([</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">],[</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">],[</span><span class="mi">25</span> <span class="mi">25</span><span class="p">],[</span><span class="mi">1</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>The method expects (slave_dofs, row, col, val) for describing the entries of the C matrix.
The first argument slave_dofs is a list of dof-ids that shall function as slave-dofs.
The (row, col, val) triple describes the entries of the sparse C matrix.
Therefore col consists of ids of master-dofs.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">One can call the method
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.add_constraints" title="amfe.boundary.DirichletBoundary.add_constraints"><code class="xref py py-meth docutils literal"><span class="pre">DirichletBoundary.add_constraints</span></code></a>
several times. Then the new values for row, col and val are added to the ones before.
You have to be careful if a (row, col)-pair has already been set. Then you will see unexpected behavior.</p>
</div>
<p>The B matrix is generated such that</p>
<div class="math">
\[\begin{split}\begin{bmatrix} \vec u_{master} \\
\vec u_{slave}
\end{bmatrix}
=
\begin{bmatrix} 1 &amp; 0 \\
C &amp; 1
\end{bmatrix}
\begin{bmatrix}
\vec u_{master} \\
\vec u_{slave}
\end{bmatrix}\end{split}\]</div>
<p>and afterwards the slave dofs-columns are dropped and one gets the relation</p>
<div class="math">
\[\begin{split}\begin{bmatrix} \vec u_{master} \\ \vec u_{slave} \end{bmatrix}
=
\underbrace{\begin{bmatrix} 1 \\ C \end{bmatrix}}_B
\vec u_{master}\end{split}\]</div>
<p>The matrix B is stored in the <a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.B" title="amfe.boundary.DirichletBoundary.B"><code class="xref py py-attr docutils literal"><span class="pre">B</span></code></a>-property of the DirichletBoundary-class.</p>
<div class="section" id="more-convenient-way-the-master-slave-list">
<h3>More convenient way - the master-slave list<a class="headerlink" href="#more-convenient-way-the-master-slave-list" title="Permalink to this headline">¶</a></h3>
<p>There is a more convenient way to apply constraints that relate several slave degrees of freedom to only one
master degree of freedom by using the
<a class="reference internal" href="../package_doc/amfe.boundary.html#amfe.boundary.DirichletBoundary.apply_master_slave_list" title="amfe.boundary.DirichletBoundary.apply_master_slave_list"><code class="xref py py-meth docutils literal"><span class="pre">apply_master_slave_list()</span></code></a>-method.
This method expects one argument, a so called master-slave-list.
The type of this argument is a list that contains triplets of master-slave-relations.
One triplet consists of</p>
<ol class="arabic simple">
<li>integer: a master-dof</li>
<li>list: slave-dofs</li>
<li>ndarray: weighting-matrix</li>
</ol>
<p>Then the relation <span class="math">\(u_{slave} = W^T \, u_{master}\)</span> is imposed to the system where W is the weighting matrix.
If None is used for the weighting matrix, then all dofs are weighted by one</p>
<p>The following example shows how x-direction of all dofs belonging to physical group 101 can be equalized:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nodes</span><span class="p">,</span> <span class="n">dofs</span> <span class="o">=</span> <span class="n">msh</span><span class="o">.</span><span class="n">set_dirichlet_bc</span><span class="p">(</span><span class="mi">101</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;external&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dic</span><span class="o">.</span><span class="n">apply_master_slave_list</span><span class="p">([[</span><span class="n">dofs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dofs</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="kc">None</span><span class="p">],])</span>
</pre></div>
</div>
<p>In the example above the option &#8216;external&#8217; is used to get all global dofs which belong to x-direction and
to the physical group with id 101. Afterwards the first returned dof is taken as master_dof and the rest as slave-dofs.</p>
</div>
</div>
<div class="section" id="neumann-boundary-conditions">
<h2>Neumann Boundary Conditions<a class="headerlink" href="#neumann-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>Neumann Boundary conditions in structural dynamics represent external forces.</p>
<div class="section" id="how-neumann-boundary-conditions-are-organized-in-amfe">
<h3>How Neumann Boundary Conditions are organized in AMfe<a class="headerlink" href="#how-neumann-boundary-conditions-are-organized-in-amfe" title="Permalink to this headline">¶</a></h3>
<p>Neumann boundary conditions are implemented by
<a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement" title="amfe.element.BoundaryElement"><code class="xref py py-class docutils literal"><span class="pre">BoundaryElement</span></code></a> s.
These elements are very similar to simple elements of the continuum. They are assembled like the continuum elements.
However typically their shape is one dimension lower than the dimension of the problem.</p>
<p>In detail one have to do two steps to apply Neumann boundary conditions:</p>
<ol class="arabic simple">
<li>Define the boundary elements that represent the forces one want to impose.</li>
<li>Update the assembly information by calling
<a class="reference internal" href="../package_doc/amfe.assembly.html#amfe.assembly.Assembly.compute_element_indices" title="amfe.assembly.Assembly.compute_element_indices"><code class="xref py py-meth docutils literal"><span class="pre">Assembly.compute_element_indices</span></code></a></li>
</ol>
<p>Both steps can be done easily by using the method
<a class="reference internal" href="../package_doc/amfe.mechanical_system.html#amfe.mechanical_system.MechanicalSystem.apply_neumann_boundaries" title="amfe.mechanical_system.MechanicalSystem.apply_neumann_boundaries"><code class="xref py py-meth docutils literal"><span class="pre">MechanicalSystem.apply_neumann_boundaries()</span></code></a>
This is explained in the section about the MechanicalSystem fundamentals.</p>
<p>The following section goes more in detail in how AMfe processes Neumann Boundary conditions and how the first step
i.e. defining boundary elements can be done.</p>
</div>
<div class="section" id="boundary-elements">
<h3>Boundary Elements<a class="headerlink" href="#boundary-elements" title="Permalink to this headline">¶</a></h3>
<p>In AMfe so called boundary elements are used to apply Neumann boundary conditions. They are processed similar to
continuum elements and are assembled like them. The assembly method for the boundary elements is
<a class="reference internal" href="../package_doc/amfe.assembly.html#amfe.assembly.Assembly.assemble_k_and_f_neumann" title="amfe.assembly.Assembly.assemble_k_and_f_neumann"><code class="xref py py-meth docutils literal"><span class="pre">Assembly.assemble_k_and_f_neumann()</span></code></a>.
This function assembles all elements that are defined in the associated mesh. Their definition is stored in the
<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.neumann_connectivity" title="amfe.mesh.Mesh.neumann_connectivity"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.neumann_connectivity</span></code></a> and
<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.neumann_obj" title="amfe.mesh.Mesh.neumann_obj"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.neumann_obj</span></code></a> property.</p>
<p>Similar to the continuum elements, the <a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.neumann_obj" title="amfe.mesh.Mesh.neumann_obj"><code class="xref py py-attr docutils literal"><span class="pre">Mesh.neumann_obj</span></code></a> property
stores pointers to instances of NeumannBoundary classes.
While for continuum elements one needs one instance for each type of element and material, one needs
for Neumann elements one instance for each type of Neumann element and boundary condition definition e.g. for each
different time dependence, scale values etc.</p>
<p><a class="reference internal" href="#tab-boundary-element-properties"><span class="std std-numref">Table 6</span></a> lists the properties of boundary elements.</p>
<table border="1" class="docutils" id="id3">
<span id="tab-boundary-element-properties"></span><caption><span class="caption-number">Table 6 </span><span class="caption-text">Important properties of Boundary Elements</span><a class="headerlink" href="#id3" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Property</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement.f_proj" title="amfe.element.BoundaryElement.f_proj"><code class="xref py py-attr docutils literal"><span class="pre">f_proj</span></code></a></td>
<td>Contains a function that returns the local force vector for assembly when f_mat and direction is given</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement.time_func" title="amfe.element.BoundaryElement.time_func"><code class="xref py py-attr docutils literal"><span class="pre">time_func</span></code></a></td>
<td>Contains a function that amplifies the applied force value over time</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement.val" title="amfe.element.BoundaryElement.val"><code class="xref py py-attr docutils literal"><span class="pre">val</span></code></a></td>
<td>Scale factor for applied force</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement.direct" title="amfe.element.BoundaryElement.direct"><code class="xref py py-attr docutils literal"><span class="pre">direct</span></code></a></td>
<td>direction of applied force given as vector in global coordinate system or set as &#8216;normal&#8217; for forces normal to surface</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement.f" title="amfe.element.BoundaryElement.f"><code class="xref py py-attr docutils literal"><span class="pre">f</span></code></a></td>
<td>local external force vector for assembly</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement.K" title="amfe.element.BoundaryElement.K"><code class="xref py py-attr docutils literal"><span class="pre">K</span></code></a></td>
<td>local external tangent stiffness matrix (typically zero for boundary elements)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../package_doc/amfe.element.html#amfe.element.BoundaryElement.M" title="amfe.element.BoundaryElement.M"><code class="xref py py-attr docutils literal"><span class="pre">M</span></code></a></td>
<td>local external mass matrix (typically zero for boundary elements)</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="convenient-way-using-the-set-neumann-bc-method">
<h3>Convenient way - Using the set_neumann_bc-method<a class="headerlink" href="#convenient-way-using-the-set-neumann-bc-method" title="Permalink to this headline">¶</a></h3>
<p>If the Neumann boundary conditions should act on all elements that belong to a certain physical group, the definition
of the boundary elements is quite easy. We can use the method
<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.set_neumann_bc" title="amfe.mesh.Mesh.set_neumann_bc"><code class="xref py py-meth docutils literal"><span class="pre">Mesh.set_neumann_bc()</span></code></a>.</p>
<p>This method expects the following parameters:</p>
<table border="1" class="docutils" id="id4">
<span id="tab-parameters-set-neumann-bc"></span><caption><span class="caption-number">Table 7 </span><span class="caption-text">Parameters for the method set_neumann_bc</span><a class="headerlink" href="#id4" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">key</th>
<th class="head">value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>key</td>
<td>key of mesh property e.g. id of physical group where neumann boundary condition should be applied</td>
</tr>
<tr class="row-odd"><td>val</td>
<td>scale factor for applied force</td>
</tr>
<tr class="row-even"><td>direct</td>
<td>direct = &#8216;normal&#8217; (default) or numpy vector that shows in the direction where the force has to be applied</td>
</tr>
<tr class="row-odd"><td>time_func=None (optional)</td>
<td>time_func = function dependent on a parameter t which amplifies applied force over time</td>
</tr>
<tr class="row-even"><td>shadow_area=False (optional)</td>
<td>boolean value. False: force is proportional to full current area. True: force is proportional to on passed vector &#8216;direct&#8217; projected area</td>
</tr>
<tr class="row-odd"><td>mesh_prop=&#8217;phys_group&#8217; (optional)</td>
<td>chooses mesh property the parameter &#8216;key&#8217; belongs to</td>
</tr>
</tbody>
</table>
<p>Example: Apply Neumann Boundary condition on physical group number 105 in x direction growing linearly in 2 seconds up to 150 per length unit:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># mesh operations to define mesh ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">linear_func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">t</span><span class="o">/</span><span class="mi">2</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span><span class="o">.</span><span class="n">set_neumann_bc</span><span class="p">(</span><span class="mi">105</span><span class="p">,</span><span class="mi">150</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span><span class="n">time_func</span><span class="o">=</span><span class="n">linear_func</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asm</span><span class="o">.</span><span class="n">compute_element_indices</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="hard-way-defining-boundary-elements-by-hand">
<h3>Hard way - Defining boundary elements by hand<a class="headerlink" href="#hard-way-defining-boundary-elements-by-hand" title="Permalink to this headline">¶</a></h3>
<div class="figure" id="id5">
<span id="simple-neumann-manually"></span><img alt="../../_images/neumann_01.svg" src="../../_images/neumann_01.svg" /><p class="caption"><span class="caption-number">Fig. 7 </span><span class="caption-text">Neumann</span></p>
</div>
<p><a class="reference internal" href="#simple-neumann-manually"><span class="std std-numref">Fig. 7</span></a> shows.</p>
<p>Example: Define LineLinearBoundary-Element between nodes 2 and 5 with linear increasing value up to 10 per length unit
and acting in x-direction:</p>
<div class="highlight-python3"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span><span class="o">.</span><span class="n">neumann_connectivity</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msh</span><span class="o">.</span><span class="n">neumann_obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">amfe</span><span class="o">.</span><span class="n">LineLinearBoundary</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">direct</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">time_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">asm</span><span class="o">.</span><span class="n">compute_element_indices</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="mesh-tying">
<h2>Mesh-Tying<a class="headerlink" href="#mesh-tying" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">This is not documented yet. See documentation of the <a class="reference internal" href="../package_doc/mesh_tying.html#module-amfe.mesh_tying" title="amfe.mesh_tying"><code class="xref py py-mod docutils literal"><span class="pre">mesh_tying</span></code></a> module and
<a class="reference internal" href="../package_doc/amfe.mesh.html#amfe.mesh.Mesh.tie_mesh" title="amfe.mesh.Mesh.tie_mesh"><code class="xref py py-meth docutils literal"><span class="pre">Mesh.tie_mesh</span></code></a>.</p>
</div>
</div>
</div>


        </div>
        <div class="row">
            
    <ul class="pager">
      <li class="previous">
        <a href="assembly.html" title="Assembly">&laquo; Previous</a>
      </li>
      <li class="previous">
        <a href="index.html" title="Fundamentals" accesskey="U">up</a>
      </li>
    <li class="next">
     <a href="mechanical_system.html" title="Mechanical System">next &raquo;</a>
    </li>
      </ul>
        </div>
    </div>

    
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
<script src="../../_static/js/bootstrap.min.js"></script>
<script src="../../_static/js/theme.js"></script>
<script>loader();</script>

      <div class="clearer"></div>
    </div>
  </body>
</html>